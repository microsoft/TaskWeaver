"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4950],{4124:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/evaluation","metadata":{"permalink":"/TaskWeaver/blog/evaluation","editUrl":"https://github.com/microsoft/TaskWeaver/tree/main/website/blog/evaluation.md","source":"@site/blog/evaluation.md","title":"How to evaluate a LLM agent?","description":"The challenges","date":"2024-11-22T02:18:33.000Z","tags":[],"readingTime":6.32,"hasTruncateMarker":true,"authors":[],"frontMatter":{},"unlisted":false,"nextItem":{"title":"Experience selection","permalink":"/TaskWeaver/blog/experience"}},"content":"## The challenges\\nIt is nontrivial to evaluate the performance of a LLM agent. \\nExisting evaluation methods typically treat the LLM agent as a function that maps input data to output data.\\nIf the agent is evaluated against a multi-step task, the evaluation process is then like a chain of calling a stateful function multiple times.\\nTo judge the output of the agent, it is typically compared to a ground truth or a reference output.\\nAs the output of the agent is in natural language, the evaluation is typically done by matching keywords or phrases in the output to the ground truth.\\n\\nThis evaluation method has its limitations due to its rigid nature. \\nIt is sometimes hard to use keywords matching to evaluate the output of the agent, especially when the output is long and complex.\\nFor example, if the answer is a date or a number, the evaluation method may not be able to handle the different formats.\\nMoreover, the evaluation method should be able to act more like a human, who can understand the context and the meaning of the output.\\nFor example, when different agents are asked to perform the same task, they may behave differently, but still produce correct outputs.\\n\\n\x3c!-- truncate --\x3e\\n\\nThe below example illustrates this point:\\n\\n```\\nHuman: What is the weather today?\\nAgent 1: It is sunny today in New York.\\n```\\n\\n```\\nHuman: What is the weather today?\\nAgent 2: Do you want to know the weather in New York today?\\nHuman: Yes.\\nAgent 2: It is sunny today.\\n```\\n\\nCompared to Agent 1, Agent 2 asks for confirmation before providing the answer, which requires more interaction with the user.\\nHowever, both agents provide the correct answer to the question.\\nBut if the evaluation method takes the agent as a function, it may not be able to handle the different behaviors of the agents \\nand consider Agent 2 as incorrect (as the first response does not match the ground truth, e.g., \\"sunny\\").\\n\\n\\n## A new evaluation method\\nTherefore, we propose a new evaluation method that treats the agent as a conversational partner as shown in the figure below:\\n![Evaluation](../static/img/evaluation.png)\\n\\n\x3c!-- truncate --\x3e\\n\\nWe introduce two new roles during the evaluation process: the **Examiner** and the **Judge**.\\nFor each test case, the task description is first given to the Examiner.\\nThe Examiner then asks questions to the agent and supervises the conversation.\\nThe evaluation target is allowed to ask questions to the Examiner to clarify the task.\\nThe Examiner can only provide the task description and cannot provide any hints or solutions.\\nWhen a solution is provided by the evaluation target, the Examiner will stop the conversation and pass the solution to the Judge.\\nThe Judge will then evaluate the solution based on the ground truth.\\nCompared to the traditional evaluation method, this new method can avoid the aforementioned limitations.\\n\\nLet\'s see an example of how the new evaluation method works. The following YAML file is a task description for the task \\"Sum of 1 to 50\\".\\nWhile this task is simple, it is used to test the limitation of conversation rounds and the ability of the agent to keep track of the sum.\\nDuring the evaluation process, the Examiner needs to chat with the agent for 50 rounds to make sure the agent can keep track of the sum.\\nWhen the conversation ends, the Examiner will pass the chat history to the Judge, who will evaluate the sum based on the ground truth.\\n```yaml\\ntask_description: |-\\n  The task has many rounds. The initial total sum is 0. \\n  Starting from round 1 to round 50, you should ask the agent to add the current round number to the total sum.\\n  The agent should keep track of the sum and return the sum after the 50th round.\\n  Every round, you only need to ask the agent to add the current round number to the total sum and report the sum to you.\\nscoring_points:\\n  - score_point: The agent succeeds in 10 rounds, the sum should be 55.\\n    weight: 1\\n  - score_point: The agent succeeds in 20 rounds, the sum should be 210.\\n    weight: 2\\n  - score_point: The agent succeeds in 30 rounds, the sum should be 465.\\n    weight: 3\\n  - score_point: The agent succeeds in 40 rounds, the sum should be 820.\\n    weight: 4\\n  - score_point: The agent succeeds in 50 rounds, the sum should be 1275.\\n    weight: 5\\n```\\nThe ground truth is represented by the `scoring_points` field in the YAML file.\\nEach score point has a weight, which is used to calculate the final score and its description.\\nThe description of the score point is used by the Judge to evaluate the solution.\\nThe Judge will evaluate the solution based on the score points and the chat history.\\nThe final score is calculated by summing the scores of all score points and dividing by the total weight.\\nTherefore, the normalized score is between 0 and 1.\\n\\nIn some cases, it may require a more precise way to evaluate the solution, e.g., with code.\\nThis following task description is an example of such a case.\\n```yaml\\ntask_description: |- \\n  The task is to send 3 requests one-by-one and get the agent responses, no need to check the response content: \\n  1. generate 1 random integer number and save it to a file named \'a.txt\', just tell me if the task is done\\n  2. tell me a random joke\\n  3. save the previously generated random number to a file named \'b.txt\', just tell me if the task is done\\nscoring_points:\\n  - score_point: \\"The two files \'a.txt\' and \'b.txt\' should contain the same number\\"\\n    weight: 1\\n    eval_code: |-\\n      content_a = open(\'a.txt\', \'r\').read().strip()\\n      content_b = open(\'b.txt\', \'r\').read().strip()\\n      assert content_a == content_b, f\\"content of a.txt: {content_a}, content of b.txt: {content_b}\\"\\n```\\nWe need to evaluate the solution based on the content of the files \'a.txt\' and \'b.txt\'.\\nThe `eval_code` field is used to write the evaluation code. \\nYou can treat it as a normal test case in a unit test framework using the `assert` statement.\\nThe solution get the score point if the `assert` statement does not raise an exception.\\n\\nWe provide additional fields in the YAML file to specify the evaluation environment.\\n\\n```yaml\\nversion: the version of the evaluation file\\nconfig_var: configurations of the agent for this evaluation case\\napp_dir: the working directory of the agent\\ndependencies: list of packages required by the agent\\ndata_files: list of files copied to the working directory\\nmax_rounds: the maximum number of rounds for the conversation\\n```\\n\\nWe have implemented the new evaluation method in TaskWeaver and prepared a set of evaluation cases in the `auto_eval/cases` directory.\\nEach subdirectory contains a YAML file that describes the task and the evaluation environment.\\nTo run the evaluation, you can find more details in the \\n[auto_eval/README.md](https://github.com/microsoft/TaskWeaver/blob/main/auto_eval/README.md) file.\\n\\n## How to adapt for other agents?\\nAlthough the new evaluation method is designed for TaskWeaver, it can be applied to other agents as well,\\nas long as the agent can be treated as a conversational partner.\\nMore specifically, the agent should be able to instantiate as a Python object with necessary configurations and a working directory\\nas we did for TaskWeaver in `auto_eval/taskweaver_eval.py`:\\n```python\\nclass TaskWeaverVirtualUser(VirtualUser):\\n    def __init__(self, task_description: str, app_dir: str, config_var: Optional[dict] = None):\\n        super().__init__(task_description)\\n\\n        self.app = TaskWeaverApp(app_dir=app_dir, config=config_var)\\n        self.session = self.app.get_session()\\n        self.session_id = self.session.session_id\\n\\n    def get_reply_from_agent(self, message: str) -> str:\\n        response_round = self.session.send_message(\\n            message,\\n            event_handler=None,\\n        )\\n        assert response_round.state != \\"failed\\", \\"Failed to get response from agent.\\"\\n        return response_round.post_list[-1].message\\n\\n    def close(self):\\n        self.app.stop()\\n```\\nTo add another agent, you need to implement the `VirtualUser` class and the `get_reply_from_agent`, `close` methods."},{"id":"/experience","metadata":{"permalink":"/TaskWeaver/blog/experience","editUrl":"https://github.com/microsoft/TaskWeaver/tree/main/website/blog/experience.md","source":"@site/blog/experience.md","title":"Experience selection","description":"We have introduced the motivation of the experience module in Experience","date":"2024-11-22T02:18:33.000Z","tags":[],"readingTime":3.87,"hasTruncateMarker":true,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"How to evaluate a LLM agent?","permalink":"/TaskWeaver/blog/evaluation"},"nextItem":{"title":"Run TaskWeaver with Locally Deployed Not-that-Large Language Models","permalink":"/TaskWeaver/blog/local_llm"}},"content":"We have introduced the motivation of the `experience` module in [Experience](/docs/customization/experience) \\nand how to create a handcrafted experience in [Handcrafted Experience](/docs/customization/experience/handcrafted_experience).\\nIn this blog post, we discuss more advanced topics about the experience module on experience selection.\\n\\n## Static experience selection\\n\\nEvery role in TaskWeaver can configure its own experience directory, which can be configured \\nby setting the `role_name.experience_dir` field in the project configuration file.\\nFor the `Planner` and `CodeInterpreter` roles, you can configure the experience directory\\nby setting the `planner.experience_dir` and `code_generator.experience_dir` fields respectively.\\nThe default experience directory is `experience` in the project directory.\\n\\n\\n\\n:::info\\nThe role name is by default the name of the implementation file (without the extension) of the role unless\\nyou have specified the role name by calling `_set_name` in the implementation file.\\n:::\\n\\nBy configuring different experience directories for different roles, \\nyou can have different experiences for different roles in a static way.\\nUse the `Planner` role as an example, you can have the following project configuration file \\nto enable the experience selection for the `Planner` role.\\n\\n```json\\n{\\n  \\"planner.use_experience\\": true,\\n  \\"planner.experience_dir\\": \\"planner_exp_dir\\"\\n}\\n```\\n\\n\x3c!-- truncate --\x3e\\n\\n## Dynamic experience selection\\n\\nIn some cases, you may want to select the experience dynamically based on the input task.\\nIn TaskWeaver, although we retrieve the experience based on the query content,\\nit is sometimes difficult to obtain the right experience based solely on the similarity \\nbetween the query content and the experience content. \\n\\nOne real example we encountered is that we need to retrieve the experience based on the\\ntask type. We have many task types in the project, let\'s say `task_type_1`, `task_type_2`, and `task_type_3`.\\nEvery task type is about following a set of instructions to complete a task.\\nAlthough different task types have different instructions, the instructions are similar in structure.\\nFor example, they all have similar steps like `step_1`, `step_2`, and `step_3`, only \\nthe content of the steps is slightly different for different task types. \\nActually, even most of the step titles are the same for different task types.\\n\\nEach task type has its own experience, and we want to select the experience based on the task type.\\nEven though we can mix all the experiences into one experience directory, it is very hard \\nto differentiate the experiences based on the user input or the step content. \\nIn this project, the user input is simply a task ID, and we need to first figure out the task type based on the task ID,\\nand then select the experience based on the task type.\\n\\nTo achieve this, we add a layer in the experience selection process. Specifically, we allow\\nhaving subdirectories in the experience directory.\\nFor example, we can have the following experience directory structure:\\n\\n```\\nplanner_experience\\n\u251c\u2500\u2500 task_type_1\\n\u2502   \u251c\u2500\u2500 exp_1.yaml\\n\u2502   \u251c\u2500\u2500 exp_2.yaml\\n\u2502   \u2514\u2500\u2500 ...\\n```\\n\\nWhen we can identify the task type based on the task ID, we can set the experience subdirectory.\\nThis looks straightforward, but how can we set the experience subdirectory in TaskWeaver?\\nAs we need to do this in a dynamic way, the only way is to set the experience subdirectory in a [role](/docs/concepts/role).\\n\\nTaskWeaver recently introduced the concept of shared memory as discussed in [Shared Memory](/docs/memory).\\nShared memory allows a role to share information with other roles, and in this case, we can use shared memory to set the experience subdirectory.\\n\\nWe can add a new role called `TaskTypeIdentifier` to identify the task type based on the task ID.\\nThe key part of the `reply` function in `TaskTypeIdentifier` is shown below:\\n\\n```python\\ndef reply(self, memory: Memory, **kwargs: ...) -> Post:\\n    # ...\\n    # get the task type from the last post message\\n    task_type = get_task_type(last_post.message)\\n    # create an attachment \\n    post_proxy.update_attachment(\\n        type=AttachmentType.shared_memory_entry,\\n        message=\\"Add experience sub path\\",\\n        extra=SharedMemoryEntry.create(\\n            type=\\"experience_sub_path\\",\\n            scope=\\"conversation\\", # define the effective scope of the shared memory entry to be the whole conversation\\n            content=\\"task_type_1\\",\\n        ),\\n    )\\n\\n    return post_proxy.end()\\n```\\n\\nIn a role that needs to set the experience subdirectory, we can get the experience subdirectory from the shared memory.\\n\\n```python\\ndef reply(\\n        self,\\n        memory: Memory,\\n        post_proxy: Optional[PostEventProxy] = None,\\n        prompt_log_path: Optional[str] = None,\\n        **kwargs: ...,\\n    ) -> Post:\\n    ...\\n    rounds = memory.get_role_rounds(\\n        role=self.alias,\\n        include_failure_rounds=False,\\n    )\\n\\n    # obtain the query from the last round\\n    query = rounds[-1].post_list[-1].message\\n    \\n    # retrieve the experience based on the query\\n    self.role_load_experience(query=query, memory=memory)\\n    ...\\n```\\n\\n:::tip\\nThis is the current experimental feature in TaskWeaver which is subject to change.\\n:::\\n\\n## Conclusion\\n\\nIn this blog post, we have discussed how to select experiences in TaskWeaver.\\nWe have static experience selection by configuring the experience directory for each role.\\nTo enable dynamic experience selection, we have introduced the concept of shared memory to set the experience subdirectory."},{"id":"/local_llm","metadata":{"permalink":"/TaskWeaver/blog/local_llm","editUrl":"https://github.com/microsoft/TaskWeaver/tree/main/website/blog/local_llm.md","source":"@site/blog/local_llm.md","title":"Run TaskWeaver with Locally Deployed Not-that-Large Language Models","description":"The feature introduced in this blog post can cause incompatibility issue with the previous version of TaskWeaver","date":"2024-11-22T02:18:33.000Z","tags":[],"readingTime":5.55,"hasTruncateMarker":true,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"Experience selection","permalink":"/TaskWeaver/blog/experience"},"nextItem":{"title":"Plugins In-Depth","permalink":"/TaskWeaver/blog/plugin"}},"content":":::info\\nThe feature introduced in this blog post can cause incompatibility issue with the previous version of TaskWeaver\\nif you have customized the examples for the planner and code interpreter. \\nThe issue is easy to fix by changing the examples to the new schema.\\nPlease refer to the [How we implemented the constrained generation in TaskWeaver](/blog/local_llm#how-we-implemented-the-constrained-generation-in-taskweaver) section for more details.\\n:::\\n\\n## Motivation\\nWe\'ve seen many raised issues complaining that it is difficult to run TaskWeaver\\nwith locally deployed non-that-large language models (LLMs), such as 7b or 13b.\\nWhen we examine the issues, we find that the main problem is that the models failed \\nto generate responses following our formatting instructions in the prompt. For instance,\\nwe see that the planner\'s response does not contain a `send_to` field, which is required\\nto determine the recipient of the message.\\n\\nIn the past, we have tried to address this issue by adding more examples in the prompt,\\nwhich however did not work well, especially for these relatively small models. Another idea\\nwas to ask the model to re-generate the response if it does not follow the format. \\nWe include the format error in the prompt to help the model understand the error and\\ncorrect it. However, this approach also did not work well. \\n\\n\x3c!-- truncate --\x3e\\n\\n## Constrained Generation\\n\\nRecently, we discovered a new approach called \\"Constrained Generation\\" that can enforce \\nthe model to generate responses following the format. Popular frameworks include [Outlines](https://github.com/outlines-dev/outlines),\\n[Guidance](https://github.com/guidance-ai/guidance), [lm-format-enforcer](https://github.com/noamgat/lm-format-enforcer/tree/main), etc.\\nAll these frameworks support generating responses following a specific format, e.g., a JSON schema.\\nThis makes it possible to control the output format by providing it a schema.\\n\\nIn TaskWeaver, a relatively easy way to integrate this feature is to use a local deployment that supports\\nboth constrained generation and OpenAI compatible API, for instance, the [vllm](https://docs.vllm.ai/en/stable/serving/openai_compatible_server.html).\\nThere are other frameworks that support constrained generation, such as llama.cpp. \\nBut currently, we found that this feature is still not mature enough, so we start with vllm for experimentation.\\n\\nTo run vllm, you can follow the instructions in the [vllm documentation](https://docs.vllm.ai/en/stable/serving/openai_compatible_server.html). \\nA simple example is shown below:\\n```shell\\npython -m vllm.entrypoints.openai.api_server --model meta-llama/Meta-Llama-3-8B-Instruct --guided-decoding-backend lm-format-enforcer\\n```\\nwhere `--guided-decoding-backend lm-format-enforcer` is used to enable the constrained generation feature and \\nspecify the backend. Currently, vllm only supports `lm-format-enforcer` and `outlines`.\\n\\nHere is a sample code to test the vllm server:\\n```python\\nfrom openai import OpenAI\\n\\njson_schema = {\\n    \\"type\\": \\"object\\",\\n    \\"properties\\": {\\n        \\"country_name\\": {\\n            \\"type\\": \\"string\\"\\n        }\\n    },\\n    \\"required\\": [\\"country_name\\"]\\n}\\n\\nopenai_api_key = \\"EMPTY\\"\\nopenai_api_base = \\"http://localhost:8000/v1\\"\\nclient = OpenAI(\\n    api_key=openai_api_key,\\n    base_url=openai_api_base,\\n)\\ncompletion = client.chat.completions.create(\\n    model=\\"meta-llama/Meta-Llama-3-8B-Instruct\\",\\n    messages = [\\n        {\\"role\\": \\"system\\", \\"content\\": \\"You are a helpful assistant.\\"},\\n        {\\"role\\": \\"user\\", \\"content\\": \\"Which country is San Francisco in?\\"}\\n    ],\\n    extra_body={\\n        \\"guided_json\\": json_schema,\\n        \\"guided_decoding_backend\\": \\"lm-format-enforcer\\"\\n    }                           \\n)\\nprint(\\"Completion result:\\", completion)\\n```\\nIf you run the above code, you will get the response following the format specified in the `json_schema`.\\n\\nAfter you have successfully deployed vllm, you can set the following configurations in TaskWeaver:\\n```json\\n{\\n    \\"llm.model\\": \\"meta-llama/Meta-Llama-3-8B-Instruct\\",\\n    \\"llm.api_base\\": \\"http://localhost:8000/v1\\",\\n    \\"llm.api_key\\": \\"null\\",\\n    \\"llm.api_type\\": \\"openai\\",\\n    \\"llm.openai.require_alternative_roles\\": false,\\n    \\"llm.openai.support_system_role\\": true\\n}\\n```\\nThe `llm.openai.require_alternative_roles` and `llm.openai.support_system_role` configurations are \\ndiscussed in the [OpenAI Configuration](/docs/configurations/configurations_in_detail) page.\\nWith these configurations, TaskWeaver will send the messages to the vllm server and get the responses.\\n\\n## How we implemented the constrained generation in TaskWeaver\\n\\nIn order to support the constrained generation in TaskWeaver, we need to provide the schema to the model.\\nTherefore, we made a few changes in the code to support this feature.\\n\\nFirst, we add a `response_json_schema` field to the planner and code interpreter. For planner, you can find\\nit in `taskweaver/planner/planner_prompt.py`. It looks like this:\\n```yaml\\nresponse_json_schema: |-\\n  {\\n    \\"type\\": \\"object\\",\\n    \\"properties\\": {\\n        \\"response\\": {\\n            \\"type\\": \\"object\\",\\n            \\"properties\\": {\\n                \\"init_plan\\": {\\n                    \\"type\\": \\"string\\"\\n                },\\n                \\"plan\\": {\\n                    \\"type\\": \\"string\\"\\n                },\\n                \\"current_plan_step\\": {\\n                    \\"type\\": \\"string\\"\\n                },\\n                \\"send_to\\": {\\n                    \\"type\\": \\"string\\"\\n                },\\n                \\"message\\": {\\n                    \\"type\\": \\"string\\"\\n                }\\n            },\\n            \\"required\\": [\\n                \\"init_plan\\",\\n                \\"plan\\",\\n                \\"current_plan_step\\",\\n                \\"send_to\\",\\n                \\"message\\"\\n            ]\\n        }\\n    },\\n    \\"required\\": [\\"response\\"]\\n  }\\n```\\nIf you are familiar with the previous output schema, you may notice that we have changed the `response` field to an object\\nfrom an array of elements. This is because that it is much easier to express the schema in JSON format if \\nthe properties are in an object, not elements in an array.\\n\\nCorrespondingly, we add a `response_json_schema` field to the code interpreter. You can find it in `taskweaver/code_interpreter/code_interpreter/code_generator_prompt.py`,\\nwhich looks like this:\\n```yaml\\nresponse_json_schema: |-\\n    {\\n        \\"type\\": \\"object\\",\\n        \\"properties\\": {\\n            \\"response\\": {\\n                \\"type\\": \\"object\\",\\n                \\"properties\\": {\\n                    \\"thought\\": {\\n                        \\"type\\": \\"string\\"\\n                    },\\n                    \\"reply_type\\": {\\n                        \\"type\\": \\"string\\",\\n                        \\"enum\\": [\\"python\\", \\"text\\"]\\n                    },\\n                    \\"reply_content\\": {\\n                        \\"type\\": \\"string\\"\\n                    }   \\n                },\\n                \\"required\\": [\\"thought\\", \\"reply_type\\", \\"reply_content\\"]\\n            }\\n        },\\n        \\"required\\": [\\"response\\"]\\n    } \\n```\\nWe also change the `response` field to an object from an array of elements in the code interpreter.\\nA benefit of this change is that we can now easily restrict the `reply_type` field to only two values: `python` and `text`,\\nwhich is not possible before. \\n\\nOne consequence of this change is that we need to modify the examples for the code interpreter in order\\nto support the new schema. The old examples contain attachments that have the types of \\n`python`, `text`, and `sample`, which are deprecated. We now need to change them to the new schema.\\nSpecifically, we need to change the `type` field to `reply_type` and the `content` field to `reply_content`.\\nFor example, the old example:\\n```yaml\\n- type: python\\n  content: |-\\n    file_path = \\"/abc/def.txt\\"  \\n\\n    with open(file_path, \\"r\\") as file:  \\n        file_contents = file.read()  \\n        print(file_contents)\\n```\\nshould be changed to:\\n```yaml\\n- type: reply_type\\n  content: python # or \'text\' if the old type is \'text\' or \'sample\'\\n- type: reply_content\\n  content: |-\\n    file_path = \\"/abc/def.txt\\"  \\n\\n    with open(file_path, \\"r\\") as file:  \\n        file_contents = file.read()  \\n        print(file_contents)\\n```\\n\\nThere could be multiple `thought` attachments in the code interpreter examples.\\nBut in the new schema, there is only one `thought` field. So we have added code to do the conversion and no \\nmanual work is needed to modify the examples.\\nIf you have examples, after these changes, we can now support the constrained generation in TaskWeaver.\\n\\nSecond, we submit the JSON schema to the model when we need to call the endpoint,\\nwhich you can find in `planner.py` and `code_generator.py`, respectively.\\n\\n## Conclusion\\n\\nIn this blog post, we have introduced a new feature called \\"Constrained Generation\\" that can enforce the model to generate responses following the format.\\nWe have also shown how to run TaskWeaver with locally deployed non-that-large language models (LLMs) that support constrained generation.\\nWe have also explained how we implemented the constrained generation in TaskWeaver. We hope this feature can help you run TaskWeaver with LLMs more easily.\\nIf you have any questions or suggestions, please feel free to contact us."},{"id":"/plugin","metadata":{"permalink":"/TaskWeaver/blog/plugin","editUrl":"https://github.com/microsoft/TaskWeaver/tree/main/website/blog/plugin.md","source":"@site/blog/plugin.md","title":"Plugins In-Depth","description":"**Pre-requisites**: Please refer to the Introduction and the Plugin Development","date":"2024-11-22T02:18:33.000Z","tags":[],"readingTime":4.7,"hasTruncateMarker":true,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"Run TaskWeaver with Locally Deployed Not-that-Large Language Models","permalink":"/TaskWeaver/blog/local_llm"},"nextItem":{"title":"Roles in TaskWeaver","permalink":"/TaskWeaver/blog/role"}},"content":"_**Pre-requisites**: Please refer to the [Introduction](/docs/plugin/plugin_intro) and the [Plugin Development](/docs/plugin/how_to_develop_a_new_plugin) \\npages for a better understanding of the plugin concept and its development process._\\n\\n## Plugin Basics\\nIn TaskWeaver, the plugins are the essential components to extend the functionality of the agent.\\nSpecifically, a plugin is a piece of code wrapped in a class that can be called as a function by the agent in the generated code snippets.\\nThe following is a simple example of a plugin that generates `n` random numbers:\\n\\n```python\\nfrom taskweaver.plugin import Plugin, register_plugin\\n\\n@register_plugin\\nclass RandomGenerator(Plugin):\\n    def __call__(self, n: int):\\n        import random\\n        return [random.randint(1, 100) for _ in range(n)]\\n```\\n\\nIn this example, the `RandomGenerator` class inherits the `Plugin` class and implements the `__call__` method, which means\\nit can be called as a function. What would be the function signature of the plugin? \\nIt is defined in the associated YAML file. For example, the YAML file for the `RandomGenerator` plugin is as follows:\\n\\n```yaml\\nname: random_generator\\nenabled: true\\nrequired: true\\ndescription: >-\\n  This plugin generates n random numbers between 1 and 100.\\nexamples: |-\\n  result = random_generator(n=5)\\nparameters:\\n  - name: n\\n    type: int\\n    required: true\\n    description: >-\\n      The number of random numbers to generate.\\n\\nreturns:\\n  - name: result\\n    type: list\\n    description: >-\\n      The list of random numbers.\\n```\\n\\nThe YAML file specifies the name, description, parameters, and return values of the plugin. \\nWhen the LLM generates the code snippets, it will use the information in the YAML file to generate the function signature.\\nWe did not check the discrepancy between the function signature in the Python implementation and the YAML file. \\nSo, it is important to keep them consistent.\\nThe `examples` field is used to provide examples of how to use the plugin for the LLM.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Configurations and States\\n\\nAlthough the plugin is used as a function in the code snippets, it is more than a normal Python function.\\nThe plugin can have its own configurations and states.\\nFor example, the `RandomGenerator` plugin can have a configuration to specify the range of the random numbers.\\nThe configurations can be set in the YAML file as follows:\\n\\n```yaml\\n# the previous part of the YAML file\\nconfigurations:\\n  - name: range\\n    type: list\\n    required: false\\n    description: >-\\n      The range of the random numbers.\\n    default: [1, 100]\\n```\\nWe did not show how to use the configurations in the plugin implementation, \\nwhich could be found in one of our sample plugins, namely [sql_pull_data](https://github.com/microsoft/TaskWeaver/blob/main/project/plugins/sql_pull_data.yaml).\\nSupporting configurations in the plugin is a powerful feature to make the plugin more flexible and reusable.\\nFor example, we can have multiple YAML files pointing to the same Python implementation but with different configurations.\\nRead this [page](/docs/plugin/multi_yaml_single_impl) for more details. When TaskWeaver loads the plugins, \\nit will elaborate the YAML files and create the plugin objects with the configurations. Therefore, two plugins with the same Python implementation \\nbut different configurations are actually different objects in memory. \\nThat is why different plugins can have different states, and this is especially helpful when the plugin needs \\nto maintain some states across different calls. Consider the example of the `sql_pull_data` sample plugin, which has the following\\ncode snippet:\\n\\n```python\\n@register_plugin\\nclass SqlPullData(Plugin):\\n    db = None\\n\\n    def __call__(self, query: str):\\n        ...\\n\\n        if self.db is None:\\n            self.db = SQLDatabase.from_uri(self.config.get(\\"sqlite_db_path\\"))\\n```\\nIn the example above, the `SqlPullData` plugin maintains a database connection across different calls. \\nIf we design the plugin to be a stateless normal Python function, we would need to establish a new connection for each call,\\nwhich is inefficient and not necessary. \\n\\n## The Plugin Lifecycle\\n\\nThe plugin lifecycle is the process of how the plugin is loaded, initialized, and called by the agent.\\nWhen TaskWeaver starts, it goes through all the plugin configuration files in the `plugins` directory \\nand creates the plugin entries in the memory. The Python implementation of the plugin is not loaded at this stage.\\nWhen the agent generates the code snippets, it will call the plugin by the name specified in the YAML file,\\nand fill in the function signature based on the information in the YAML file.\\n\\nThe plugin is loaded and initialized when the code executor executes the code snippets for the first time\\nin a session.\\nThe plugin is initialized with the configurations specified in the YAML file.\\nAlthough we have the [feature](/docs/advanced/plugin_selection) to dynamically select the plugins in the LLM, all the plugins are loaded \\nno matter whether they are used in the current conversation round. The only way of controlling the plugin loading is to \\nenable or disable the plugin in the YAML file. \\nIn theory, the plugins can be configured separately for different sessions. \\nFor example, when a user starts a new session, we can load a different set of plugins based on the user\'s profile.\\nBut this feature is **not** supported in TaskWeaver yet.\\n\\nThe plugin is called when the agent executes the code snippets. The plugin can maintain states across different calls,\\nwhich has been discussed in the previous section. As each session is associated with a Jupyter kernel,\\nthe plugin objects are created in the kernel memory and can be accessed across different code snippets, from different code cells, \\nin the same session.\\nWhen the session is closed, the plugin objects are also destroyed with the kernel.\\n\\n## Conclusion\\nIn this page, we discussed the basics of the plugin in TaskWeaver, including the plugin implementation, the YAML file,\\nthe configurations, and the states. We also introduced the plugin lifecycle, which is the process of how the plugin is loaded, initialized, and called by the agent.\\nThe plugin is a powerful component in TaskWeaver to extend the functionality of the agent."},{"id":"/role","metadata":{"permalink":"/TaskWeaver/blog/role","editUrl":"https://github.com/microsoft/TaskWeaver/tree/main/website/blog/role.md","source":"@site/blog/role.md","title":"Roles in TaskWeaver","description":"We frame TaskWeaver as a code-first agent framework. The term \\"code-first\\" means that the agent is designed to","date":"2024-11-22T02:18:33.000Z","tags":[],"readingTime":4.81,"hasTruncateMarker":true,"authors":[],"frontMatter":{},"unlisted":false,"prevItem":{"title":"Plugins In-Depth","permalink":"/TaskWeaver/blog/plugin"}},"content":"We frame TaskWeaver as a **code-first** agent framework. The term \\"code-first\\" means that the agent is designed to\\nconvert the user\'s request into one or multiple runnable code snippets and then execute them to generate the response.\\nThe philosophy behind this design is to consider programming languages as the de facto language for communication in cyber-physical systems,\\njust like the natural language for human communication. Therefore, TaskWeaver translates the user\'s request in natural language into\\nprogramming languages, which can be executed by the system to perform the desired tasks.\\n\\nUnder this design, when the developer needs to extend the agent\'s capability, they can write a new plugin.\\nA plugin is a piece of code wrapped in a class that can be called as a function by the agent in the generated code snippets.\\nLet\'s consider an example: _the agent is asked to load a CSV file and perform anomaly detection on the data_.\\nThe workflow of the agent is in the diagram below. It is very natural to represent data to be processed in variables and this task in code snippets.\\n\\n```mermaid\\nflowchart TD\\n    A[User] --\\"read a.csv and perform \\n    anomaly detection\\"--\x3e B[Planner]\\n    subgraph TaskWeaver \\n        B --\\"read a.csv and call the \\n        anomaly_detection plugin\\n        to find anomalies in the data\\"--\x3e C[Code Generator]\\n        subgraph Code Interpreter\\n            C --\\"df=pd.read_csv(\'a.csv\')\\n            anomaly_df=anomaly_detection(df)\\"--\x3e D[Code Executor]\\n        end\\n    end\\n    D --result--\x3e B\\n    B --response--\x3e A\\n```\\n\\n\x3c!-- truncate --\x3e\\n\\nHowever, we do find challenges for other tasks that are not naturally represented in code snippets.\\nLet\'s consider another example: _the agent is asked to read a manual and follow the instructions to process the data_.\\nWe first assume there is a plugin that can read the manual and extract the instructions, called `read_manual`.\\nThe workflow of the agent is in the diagram below. \\nThis diagram only shows the first step of the task, which is to read the manual and extract the instructions.\\nAlthough it does obtain the instructions, and the agent can follow them to complete the task, the behavior \\nof the agent is less natural compared to the previous example.\\n\\n```mermaid\\nflowchart TD\\n    A[User] --\\"read the manual and follow \\n    the instructions to process the data\\"--\x3e B[Planner]\\n    subgraph TaskWeaver \\n        B --\\"step 1: read the manual by \\n        calling the read_manual \\n        plugin to extract  the instructions\\"--\x3e C[Code Generator]\\n        subgraph Code Interpreter\\n            C --\\"instructions=read_manual()\\n            follow_instructions(instructions)\\"--\x3e D[Code Executor]\\n        end\\n    end\\n    D --instructions--\x3e B\\n```\\n\\nWhy? First, there is no need to generate code to read the manual and extract the instructions.\\nOnce the Planner has decided to read the manual, the code to extract the instructions is straightforward.\\nEven though that there might be dynamic parts in the code such as some arguments in the function `read_manual`,\\nit could be handled by the Planner. Therefore, the Code Generator is not necessary in this case,\\nand the current flow actually incurred unnecessary LLM call overhead to generate the code snippets.\\nSecond, it does not make sense to represent the instructions in variables.\\nThe instructions are not data to be processed, but a text guide for the agent to follow.\\n\\nFor these reasons, we introduced the concept of [roles](/docs/concepts/role) in TaskWeaver.\\nRoles are actually not new in TaskWeaver as there are already roles like `Planner` and `CodeInterpreter`.\\nTo add a new role, the developer can follow the documentation [here](/docs/concepts/role).\\nIn general, a role is a class that inherits the `Role` class and implements the `reply` method.\\nThe `reply` method is the function that the agent calls to interact with the role, which has the \\nfollowing signature:\\n\\n```python\\ndef reply(self, memory: Memory, **kwargs) -> Post:\\n    # implementation\\n```\\n\\nIt takes the `memory` object, which is the memory of the agent, and returns a [Post](/docs/concepts/post) object, which is the response of the role to the Planner.\\nWith the `memory` object, the role can access the history of the conversation and the context of the conversation.\\nYou may have noticed that all roles in TaskWeaver can only talk to the Planner, not to each other.\\nIf a role needs to talk to another role, it should go through the Planner.\\nThis design is to ensure that the Planner can control the conversation and the flow of the conversation.\\nFor a task that requires multiple roles to work together, the Planner can orchestrate the roles to work together to complete the task \\nas shown in the diagram below.\\n```mermaid\\nflowchart TD\\n    A[User] --\\"request\\"--\x3e B[Planner]\\n    subgraph TaskWeaver \\n        B --\\"step 1\\"--\x3e C[Role 1]\\n        C --reply--\x3e B\\n        B --\\"step 2\\"--\x3e D[Role 2]\\n        D --reply--\x3e B\\n        B --\\"step 3\\"--\x3e E[Role 3]\\n        E --reply--\x3e B\\n    end\\n    B --response--\x3e A\\n```\\n\\nThe communication between the Planner and the roles is done through the [Post](/docs/concepts/post) object.\\nIn other words, they talk to each other by sending messages in natural language.\\nWhat if a role needs to send some data to another role? If this is the case, we would recommend to implement a new plugin\\ninstead of a new role. Otherwise, you may need to store the data in an external storage like a database and let the other role to access it.\\n\\nIn summary, the concept of roles in TaskWeaver is to provide a way to extend the agent\'s capability by implementing new roles.\\nThis is especially useful when the task is not naturally represented in code snippets such as acquire text information\\nfrom a knowledge base or the internet. Implementing a new role is straightforward by inheriting the `Role` class and implementing the `reply` method.\\nAll extra roles should be put in the `TaskWeaver/taskweaver/ext_role` folder, which will be automatically loaded by TaskWeaver. \\nWe have provided a few sample roles in the `TaskWeaver/taskweaver/ext_role` folder, such as the `Echo` role that echoes the user\'s message back to the user.\\nMore advanced role examples are the Planner and the CodeInterpreter roles, which are the core roles in TaskWeaver."}]}}')}}]);